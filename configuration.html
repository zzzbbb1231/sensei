---
layout: default
title: SenseiBA - Configuration
name: configuration
---
<div class="hero-unit">
	<h2>SenseiBA configuration</h2>
	<p>		
  Guide to configure your application.
	</p>
</div>
   
<h2>Configuration files</h2>
<p>A SenseiBA node is configured by a set of files. These files describe
    a Sensei node in terms of data models, server configuration, indexing
    tuning parameters, customizations, etc.</p>

<p>
  SenseiBA configuration is a directory containing a couple of files:
  <ul>
    <li>sensei.properties - settings for a SenseiBA node or process</li>
    <li>schema.xml - data schema declaration - only needed for the realtime indexing</li>
  </ul>
</p>


<h2>Sensei Properties</h2>
<p>
  As SenseiBA is built on top of SenseiDB. It inherits most of its config parameters from SenseiDB. Here is the Sensei's comprehensive config guide - <a href="http://senseidb.github.com/sensei/configuration.html">http://senseidb.github.com/sensei/configuration.html</a>
</p>
<p>We've also assembled some config sample with comments</p>
<pre>
#This is the node ID of the Sensei node in a cluster.
sensei.node.id=1

#This specifies the partitions IDs this the Sensei server is going to handle. Partition IDs can be given as either integer numbers or ranges, separated by commas. 
#For example, the following line denotes that the Sensei server has six partitions: 1,4,5,6,7,10.
#In case of realtime indexing there should be only one partition per node
sensei.node.partitions=0-7

#This is the maximum partition ID number served by this Sensei cluster if the default Sensei indexing manager is used.
sensei.index.manager.default.maxpartition.id = 7

#Sensei rpc port
sensei.server.port=12210

#This is the core size of thread pool used to execute requests.
sensei.server.requestThreadCorePoolSize=20

#This is the maximum size of thread pool used to execute requests.
sensei.server.requestThreadMaxPoolSize=70

#This is the length of time in seconds to keep an idle request thread alive.
sensei.server.requestThreadKeepAliveTimeSecs=300

# sensei cluster parameters
#This is the name of the Sensei server cluster.
sensei.cluster.name=ba-server

#The name of the node's rpc client. Used in Zookeeper registration
sensei.cluster.client-name=server1

#This is the ZooKeeper URL for the Sensei cluster.
sensei.cluster.url=localhost:2181

#RPC timeout
sensei.cluster.timeout=30000

#The maximum amount of time, that broker would wait prior to sending back an error, if the node becomes unresponsive
sensei.broker.timeout=50000

# broker properties
#Http port, that Sensei is listens for incoming requests
sensei.broker.port = 8080

#This is the minimum size of thread pool used by a broker to execute requests.
sensei.broker.minThread = 50

#This is the maximum size of thread pool used by a broker to execute requests.
sensei.broker.maxThread = 100

#This is the maximum idle time in milliseconds for a thread on a broker. Threads that are idle for longer than this period may be stopped.
sensei.broker.maxWaittime = 2000

#This is the resource base of the broker web application.
sensei.broker.webapp.path=config/webapp

#This is the Sensei cluster name, i.e. the service name for the network clients and brokers.
sensei.search.cluster.name = ba-server

#The name of the node's rpc client. Used in Zookeeper registration
sensei.search.cluster.client-name = server1

#This is the ZooKeeper URL for the Sensei cluster.
sensei.search.cluster.zookeeper.url = localhost:2181

#Zookeeper timeout
sensei.search.cluster.zookeeper.conn.timeout = 30000
</pre>
<h2>Offline server config properties</h2>
<pre>
#tells the Sensei to reference DirectoryBasedFactoryManager as the indexer
sensei.indexer.type=ba.index.factory

# Designates where to store indexes
#Possible values: Heap, MemoryMapped, DirectMemory
ba.index.factory.readMode=Heap
ba.index.factory.class=com.senseidb.ba.management.directory.DirectoryBasedFactoryManager

# The directory where indexes are stored
sensei.index.directory=/tmp/ba-index-standalone

#Specifies that the http endpoint should be started at port 9092 to accept the segments via http and to register them within the cluster
httpServer.class=com.senseidb.ba.file.http.JettyServerHolder
httpServer.port=9092
#The location of the upload directory, where the uploaded segment is stored
httpServer.directory=/tmp/fileUploadStandalone

#Standard SenseiBA customization plugins
sensei.query.builder.factory.class=com.senseidb.ba.plugins.ZeusQueryBuilderFactory
sensei.index.interpreter.class=com.senseidb.search.node.NoOpIndexableInterpreter
sensei.mapreduce.accessor.factory.class=com.senseidb.ba.mapred.BaFieldAccessorFactory
sensei.request.postrocessor.class=com.senseidb.ba.plugins.BARequestPostProcessor
sensei.index.pruner.class=com.senseidb.ba.plugins.BAIndexPruner
</pre>

<h2>Realtime indexing config properties</h2>
<p>Here is the config part for realtime ingestion using Kafka</p>
<pre>
#The directory, where segments are persisted
sensei.index.directory=/tmp/realtimeKafkaIndex/test

#indexer.type is equal to com.senseidb.ba.realtime.indexing.IndexingCoordinator
sensei.indexer.type=indexingCoordinator

indexingCoordinator.class=com.senseidb.ba.realtime.indexing.IndexingCoordinator
indexingCoordinator.dataProvider=dataProvider

#Cluster name. By default the value might be taken from sensei.cluster.name property
indexingCoordinator.clusterName=cluster

#Number of threads required to scan the persisted segments. Ussually this number should be numOfCores - 2
indexingCoordinator.numServingPartitions=6

# By reaching this limit the realtime segment is sorted and flushed to disk 
indexingCoordinator.capacity=1000000

#Time in millis that designates refresh rate
indexingCoordinator.refreshTime=2000

#The number of events that would cause the realtime index to refresh
indexingCoordinator.bufferSize=200000

# The segment would be sorted based on this columns to speed up search
indexingCoordinator.sortedColumns= id, category

#Where to store flushed indexes
#Possible values: Heap, MemoryMapped, DirectMemory
indexingCoordinator.readMode=Heap

#Kafka provider properties. One can supply other Kafka properties. They just need to start with dataProvider.kafka.
dataProvider.class=com.senseidb.ba.realtime.indexing.providers.KafkaRealtimeDataProvider

#Kafka zookeeper url
dataProvider.kafka.zk.connect=localhost:2181

#Kafka unique consumer groupID
dataProvider.kafka.groupid=4

#Comma separated list of topics
dataProvider.kafka.topics=test1

dataProvider.kafka.timeout=3000
#For SenseiBA autocommit should be always false
dataProvider.kafka.autocommit.enable=false

#Standard SenseiBA customization plugins
sensei.query.builder.factory.class=com.senseidb.ba.plugins.ZeusQueryBuilderFactory
sensei.index.interpreter.class=com.senseidb.search.node.NoOpIndexableInterpreter
sensei.mapreduce.accessor.factory.class=com.senseidb.ba.mapred.BaFieldAccessorFactory
sensei.request.postrocessor.class=com.senseidb.ba.plugins.BARequestPostProcessor
sensei.index.pruner.class=com.senseidb.ba.plugins.BAIndexPruner
sensei.index.manager.class=com.senseidb.ba.plugins.DummyIndexingManager
realtime.core.service.class=com.senseidb.ba.plugins.RealtimeCoreSenseiService
realtime.sys.service.class=com.senseidb.ba.plugins.RealtimeSysSenseiService
custom.plugins.spring.class=com.senseidb.conf.SpringSenseiPluginFactory
custom.plugins.spring.returnedClass=com.senseidb.svc.impl.AbstractSenseiCoreService
custom.plugins.spring.springFile=plugins.xml
sensei.plugin.services.list=custom.plugins.spring, realtime.core.service,realtime.sys.service
sensei.search.pluggableEngines.list=realtime.core.service,realtime.sys.service
custom.facets.spring.class=com.senseidb.conf.SpringSenseiPluginFactory
custom.facets.spring.returnedClass=com.browseengine.bobo.facets.FacetHandler, com.browseengine.bobo.facets.RuntimeFacetHandlerFactory
custom.facets.spring.springFile=custom-facets.xml
# the list of beans might be referenced both by simple name and the full prefix
sensei.custom.facets.list= custom.facets.spring
</pre>



<h2>Schema</h2>
<p>
  The Sensei schema describes the data-model of a SenseiBA application. For SenseiBA it's only relevant if the realtime ingestion is used. No facets need to be defined, just columns:
  <ul>
    <li><b>table</b> - describes how data is being persisted, can think of it as the <b><i>indexing</i></b> part of the schema.</li>   
  </ul>
</p>
<p>
  Below is an example schema for the Cars  example:
</p>
<pre class="prettyprint" id="xml">

&lt;schema 
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://javasoze.github.com/sensei/schema/sensei-schema.xsd&quot;&gt;
  &lt;table uid=&quot;id&quot;&gt;
  &lt;column name=&quot;id&quot; type=&quot;long&quot; /&gt;
    &lt;column name=&quot;groupid&quot; type=&quot;long&quot; /&gt;
    &lt;column name=&quot;color&quot; type=&quot;string&quot; /&gt;
    &lt;column name=&quot;category&quot; type=&quot;string&quot; /&gt;
    &lt;column name=&quot;city&quot; type=&quot;string&quot; /&gt;
    &lt;column name=&quot;makemodel&quot; type=&quot;string&quot; /&gt;
    &lt;column name=&quot;year&quot; type=&quot;int&quot; /&gt;
    &lt;column name=&quot;price&quot; type=&quot;float&quot; /&gt;
    &lt;column name=&quot;mileage&quot; type=&quot;int&quot; /&gt;
    &lt;column name=&quot;tags&quot; type=&quot;string&quot; multi=&quot;true&quot; delimiter=&quot;,&quot;/&gt;
  &lt;/table&gt;
   &lt;facets&gt;
   &lt;/facets&gt;
&lt;/schema&gt;
</pre>

